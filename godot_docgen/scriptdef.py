from definitions import DefinitionBase, MethodDef, ConstantDef, PropertyDef, ParameterDef, EnumDef, MethodDef, SignalDef, AnnotationDef, ThemeItemDef, TypeName
from typing import OrderedDict, Optional
from state import State
import enum
import xml.etree.ElementTree as ET
import re


class ScriptGroups(enum.Enum):
    '''
    Represents the different groups that a Godot class could be a part
    of.

    Attributes
    ----------
    VARIANT = 0
    NODE = 1
    OBJECT = 2
    RESOURCE = 3
    GLOBAL = 4
    SCRIPT = 5
    '''
    VARIANT = 0
    NODE = 1
    OBJECT = 2
    RESOURCE = 3
    GLOBAL = 4
    SCRIPT = 5


class ScriptDef(DefinitionBase):
    '''
    Class which organizes the data for a godot class in a way which makes
    it easy to convert it to a ReStructured Text file.

    Parameters
    ----------
    state : State
        The global state of the program

    Attributes
    ----------
    class_group : ScriptGroups
        The type of object that the class represents.
    constants : OrderedDict[str, ConstantDef]
    enums : OrderedDict[str, EnumDef]
    properties : OrderedDict[str, PropertyDef]
    constructors : OrderedDict[str, list[MethodDef]]
    methods : OrderedDict[str, list[MethodDef]]
    operators : OrderedDict[str, list[MethodDef]]
    signals : OrderedDict[str, SignalDef]
    annotations : OrderedDict[str, list[AnnotationDef]]
    theme_items : OrderedDict[str, ThemeItemDef]
    inherits : Optional[str]
    brief_description : Optional[str]
    description : Optional[str]
    tutorials : list[tuple[str, str]]
    keywords : Optional[str]
    '''
    script_pattern = re.compile('"?[\w /]+\.gd"?')

    def __init__(self, state: State) -> None:
        super().__init__("class", "")
        self.class_group = ScriptGroups.SCRIPT
        self.constants: OrderedDict[str, ConstantDef] = OrderedDict()
        self.enums: OrderedDict[str, EnumDef] = OrderedDict()
        self.properties: OrderedDict[str, PropertyDef] = OrderedDict()
        self.constructors: OrderedDict[str, list[MethodDef]] = OrderedDict()
        self.methods: OrderedDict[str, list[MethodDef]] = OrderedDict()
        self.operators: OrderedDict[str, list[MethodDef]] = OrderedDict()
        self.signals: OrderedDict[str, SignalDef] = OrderedDict()
        self.annotations: OrderedDict[str, list[AnnotationDef]] = OrderedDict()
        self.theme_items: OrderedDict[str, ThemeItemDef] = OrderedDict()
        self.inherits: Optional[str] = None
        self.brief_description: Optional[str] = None
        self.description: Optional[str] = None
        self.tutorials: list[tuple[str, str]] = []
        self.keywords: Optional[str] = None
        self.state = state

        # Used to match the class with XML source for output filtering purposes
        self.filepath: str = ""

    def update_class_group(self, state: State) -> None:
        group_name: ScriptGroups = ScriptGroups.VARIANT

        if self.name.startswith("@"):
            group_name = ScriptGroups.GLOBAL
        elif self.inherits:
            inherits = self.inherits.strip()

            while inherits in state.classes:
                if inherits == "Node":
                    group_name = ScriptGroups.NODE
                    break
                if inherits == "Resource":
                    group_name = ScriptGroups.RESOURCE
                    break
                if inherits == "Object":
                    group_name = ScriptGroups.OBJECT
                    break

                inode = state.classes[inherits].inherits
                if inode:
                    inherits = inode.strip()
                else:
                    break

        self.class_group = group_name

    def parse_file(self, filepath: str):
        '''
        Generates class data by parsing an xml file generated by Godot's
        --doctool command.

        Parameters
        ----------
        filepath : str
            Path to the file to parse. Should be an xml file generated by
            Godot.

        Warnings
        --------
        This method modifies state by adding a key-value pair to State.classes
        '''
        # Reads and parses the xml file
        with open(filepath, 'r') as file:
            tree = ET.parse(file)
        class_root = tree.getroot()
        class_name = class_root.attrib["name"]
        self.name = class_name
        # Checks if the script defines a class, or if it is simply a script
        # to attach to another file
        if self.script_pattern.fullmatch(self.name) is not None:
            self.name = self.name.strip('"')
            self.state.scripts[self.name] = self
        else:
            self.state.classes[self.name] = self
            self.class_group = ScriptGroups.VARIANT

        self.filepath = filepath
        # If the script is a class, find out what it inherits (if anything)
        inherits = class_root.get("inherits")
        if inherits is not None and self.class_group != ScriptGroups.SCRIPT:
            self.inherits = inherits

        self.deprecated = class_root.get("deprecated")
        self.experimental = class_root.get("experimental")
        # Gets descriptions
        brief_desc = class_root.find("brief_description")
        if brief_desc is not None and brief_desc.text.strip():
            self.brief_description = brief_desc.text.strip()
        desc = class_root.find("description")
        if desc is not None and desc.text.strip():
            self.description = desc.text.strip()

        keywords = class_root.get("keywords")
        if keywords is not None:
            self.keywords = keywords
        # Finds the member variables of the class
        properties = class_root.find("members")
        if properties is not None:
            for property in properties:
                assert property.tag == "member"
                property_def = PropertyDef(property)
                if property_def.name in self.properties:
                    print_error(f'{filepath}: Duplicate property "{property_def.name}".', self)
                    continue
                self.properties[property_def.name] = property_def
        # Finds the class methods
        methods = class_root.find("methods")
        if methods is not None:
            for method in methods:
                assert method.tag == "method"
                method_def = MethodDef(method, "method")
                # Checks for constructors
                if method_def.name == '_init':
                    method_def.definition_name = "constructor"
                    if method_def.name not in self.constructors:
                        self.constructors[method_def.name] = []
                    self.constructors[method_def.name].append(method_def)
                # Otherwise documents as a normal method
                if method_def.name not in self.methods:
                    self.methods[method_def.name] = []
                self.methods[method_def.name].append(method_def)
        # Finds any operator overloads
        # TODO: Not possible in gdscript, maybe should remove?
        operators = class_root.find("operators")
        if operators is not None:
            for operator in operators:
                assert operator.tag == "operator"
                op_def = MethodDef(operator, "operator")
                if op_def.name not in self.operators:
                    self.operators[op_def.name] = []
                self.operators[op_def.name].append(op_def)
        # Searches for constants (and enums) in the gdscript file
        constants = class_root.find("constants")
        if constants is not None:
            for constant in constants:
                assert constant.tag == "constant"
                enum = constant.get("enum")
                constant_def = ConstantDef(constant)
                # Checks if the constant is part of an enum or not
                if enum is None:
                    self.constants[constant_def.name] = constant_def
                else:
                    if enum in self.enums:
                        enum_def = self.enums[enum]
                    else:
                        enum_def = EnumDef(enum, constant_def.bitfield)
                        self.enums[enum_def.name] = enum_def
                    enum_def.values[constant_def.name] = constant_def
        # Searches for annotations
        # TODO: Manually parse .gd files to find annotations?
        annotations = class_root.find('annotations')
        if annotations is not None:
            for annotation in annotations:
                assert annotation.tag == 'annotation'
                annotation_name = annotation.attrib['name']
        # Searches for signals
        signals = class_root.find("signals")
        if signals is not None:
            for signal in signals:
                assert signal.tag == 'signal'
                signal_def = SignalDef(signal)
                self.signals[signal_def.name] = signal_def
        # TODO: We might need to add theme items, but im pretty sure we don't
        # Gets tutorials
        tutorials = class_root.find('tutorials')
        if tutorials is not None:
            for link in tutorials:
                assert link.tag == 'link'
                if link.text is not None:
                    self.tutorials.append((link.text.strip(), link.get("title", "")))
